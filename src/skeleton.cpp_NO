#include <CGAL/Fuzzy_sphere.h>
#include <glm/glm.hpp>
#include <glm/gtx/string_cast.hpp>
#include <groot/cgal_helper.hpp>
#include <groot/skeleton.hpp>
#include <groot/util.hpp>
#include <lemon/adaptors.h>
#include <lemon/dijkstra.h>
#include <lemon/kruskal.h>
#include <lemon/lgf_reader.h>
#include <lemon/lgf_writer.h>
#include <optional>
#include <spdlog/spdlog.h>

namespace groot {

std::string SearchType_Names[] = {
    "KnnSearch",
    "RadiusSearch",
    "Count"
};

namespace point_finder {
    NodeT min_coord(const PlantGraph& graph, size_t axis)
    {
        NodeT point = lemon::INVALID;
        float min_coord = +INFINITY;

        for (NodeIt n(*graph.graph); n != lemon::INVALID; ++n) {
            if ((*graph.point)[n][axis] < min_coord) {
                point = n;
                min_coord = (*graph.point)[n][axis];
            }
        }

        return point;
    }

    NodeT max_coord(const PlantGraph& graph, size_t axis)
    {
        NodeT point = lemon::INVALID;
        float max_coord = -INFINITY;

        for (NodeIt n(*graph.graph); n != lemon::INVALID; ++n) {
            if ((*graph.point)[n][axis] > max_coord) {
                point = n;
                max_coord = (*graph.point)[n][axis];
            }
        }

        return point;
    }
}

PlantGraph PlantGraph::from_search(
    glm::vec3* cloud,
    size_t count,
    const SearchParams& params)
{
    GraphT* neighbourhood(new GraphT);
    NodeMapT<glm::vec3>* points = new NodeMapT<glm::vec3>(*neighbourhood);
    EdgeMapT<float>* lengths = new EdgeMapT<float>(*neighbourhood);

    cgal::KdTree kdtree;

    for (size_t i = 0; i < count; i++) {
        NodeT node = neighbourhood->addNode();
        (*points)[node] = cloud[i];
        kdtree.insert(std::make_tuple(cloud[i], node));
    }

    kdtree.build<CGAL::Parallel_tag>();

    if (params.search == SearchType::kRadiusSearch) {
        std::list<cgal::Point3Node> search_result;
        for (NodeIt node(*neighbourhood); node != lemon::INVALID; ++node) {
            glm::vec3 point = (*points)[node];
            CGAL::Fuzzy_sphere<cgal::SearchTraits> query(point, params.radius);

            kdtree.search(std::back_inserter(search_result), query);
            for (auto it = search_result.begin(); it != search_result.end(); ++it) {
                auto edge = neighbourhood->addEdge(node, std::get<NodeT>(*it));
                lengths->set(edge, glm::distance(point, std::get<glm::vec3>(*it)));
            }
            search_result.clear();
        }
    } else if (params.search == SearchType::kKnnSearch) {
        for (NodeIt node(*neighbourhood); node != lemon::INVALID; ++node) {

            cgal::KNeighbour knn(kdtree, (*points)[node], params.k);
            for (auto it = knn.begin(); it != knn.end(); ++it) {
                auto edge = neighbourhood->addEdge(node, std::get<NodeT>(it->first));
                lengths->set(edge, it->second);
            }
        }
    }

    PlantGraph ret = PlantGraph::empty();

    ret.graph.reset(neighbourhood);
    ret.point.reset(points);
    ret.length.reset(lengths);

    return ret;
}

PlantGraph PlantGraph::from_delaunay(glm::vec3* cloud, size_t count)
{
    GraphT* neighbourhood(new GraphT);
    NodeMapT<glm::vec3>* points = new NodeMapT<glm::vec3>(*neighbourhood);
    EdgeMapT<float>* lengths = new EdgeMapT<float>(*neighbourhood);

    cgal::Delaunay delaunay;

    for (size_t i = 0; i < count; i++) {
        NodeT node = neighbourhood->addNode();
        const glm::vec3& glm_point = cloud[i];
        cgal::Point_3 point(glm_point.x, glm_point.y, glm_point.z);

        (*points)[node] = glm_point;

        cgal::Delaunay::Vertex_handle handle = delaunay.insert(point);
        handle->info() = node;
    }

    for (auto i = delaunay.finite_edges_begin(); i != delaunay.finite_edges_end(); i++) {
        cgal::Delaunay::Vertex_handle v1 = i->first->vertex(i->second);
        cgal::Delaunay::Vertex_handle v2 = i->first->vertex(i->third);

        double distance = std::sqrt(CGAL::squared_distance(v1->point(), v2->point()));

        NodeT n1 = v1->info();
        NodeT n2 = v2->info();

        lemon::ListGraph::Edge e = neighbourhood->addEdge(n1, n2);
        (*lengths)[e] = distance;
    }

    PlantGraph ret = PlantGraph::empty();

    ret.graph.reset(neighbourhood);
    ret.point.reset(points);
    ret.length.reset(lengths);

    return ret;
}

PlantGraph PlantGraph::empty()
{
    PlantGraph ret;

    GraphT* neighbourhood(new GraphT);

    ret.graph.reset(neighbourhood);
    ret.point.reset(new NodeMapT<glm::vec3>(*neighbourhood));
    ret.length.reset(new EdgeMapT<float>(*neighbourhood));
    ret.radius.reset(new NodeMapT<float>(*neighbourhood));
    ret.root_distance.reset(new NodeMapT<float>(*neighbourhood));
    ret.max_root_distance = 0.0;
    ret.root = lemon::INVALID;

    return ret;
}

PlantGraph PlantGraph::clone() const
{
    PlantGraph dest = PlantGraph::empty();

    lemon::graphCopy(*graph, *dest.graph)
        .node(root, dest.root)
        .nodeMap(*point, *dest.point)
        .nodeMap(*radius, *dest.radius)
        .nodeMap(*root_distance, *dest.root_distance)
        .edgeMap(*length, *dest.length)
        .run();

    dest.max_root_distance = max_root_distance;

    return dest;
}

PlantGraph PlantGraph::read_from_file(std::istream& input)
{
    GraphT* graph = new GraphT;
    auto points = new NodeMapT<glm::vec3>(*graph);
    auto radii = new NodeMapT<float>(*graph);
    auto lengths = new EdgeMapT<float>(*graph);
    auto root_distances = new NodeMapT<float>(*graph, 0);

    NodeT root_node;

    PlantGraph ret;

    lemon::graphReader(*graph, input)
        .nodeMap("point", *points, GlmFromString<glm::vec3>())
        .nodeMap("radius", *radii)
        .nodeMap("distances_to_root", *root_distances)
        .edgeMap("length", *lengths)
        .node("root", root_node)
        .attribute("max_root_distance", ret.max_root_distance)
        .run();

    ret.graph.reset(graph);
    ret.point.reset(points);
    ret.length.reset(lengths);
    ret.radius.reset(radii);
    ret.root_distance.reset(root_distances);
    ret.root = root_node;

    return ret;
}

void PlantGraph::write_to_file(std::ostream& output)
{
    lemon::graphWriter(*this->graph, output)
        .nodeMap("point", *this->point, GlmToString<glm::vec3>())
        .nodeMap("radius", *this->radius)
        .nodeMap("distances_to_root", *this->root_distance)
        .edgeMap("length", *this->length)
        .node("root", this->root)
        .attribute("max_root_distance", this->max_root_distance)
        .run();
}

PlantGraph& PlantGraph::geodesic()
{
    NodeMapT<float> distances(*graph);
    NodeMapT<ArcT> pred(*graph);

    // Compute minimum weight tree from the root
    lemon::Dijkstra<GraphT, EdgeMapT<float>> path_calculator(*graph, *length);

    assert(root != lemon::INVALID);

    path_calculator
        .distMap(distances)
        .predMap(pred)
        .run(root);

    EdgeMapT<bool> shortest_paths(*graph, false);
    for (NodeIt n(*graph); n != lemon::INVALID; ++n) {
        if (pred[n] != lemon::INVALID) {
            shortest_paths[pred[n]] = true;
        }

        if (path_calculator.reached(n)) {
            float d = path_calculator.dist(n);
            (*root_distance)[n] = d;
            if (d > max_root_distance) {
                max_root_distance = d;
            }
        } else {
            (*root_distance)[n] = INFINITY;
        }
    }

    auto filtered = lemon::filterEdges(*graph, shortest_paths);

    PlantGraph dest = PlantGraph::empty();

    lemon::graphCopy(filtered, *dest.graph)
        .nodeMap(*point, *dest.point)
        .nodeMap(*radius, *dest.radius)
        .nodeMap(*root_distance, *dest.root_distance)
        .edgeMap(*length, *dest.length)
        .node(root, dest.root)
        .run();
    dest.max_root_distance = max_root_distance;

    *this = std::move(dest);
    return *this;
}

PlantGraph& PlantGraph::minimum_spanning_tree()
{
    EdgeMapT<bool> min_cost(*graph, false);
    lemon::kruskal(*graph, *length, min_cost);

    auto filtered = lemon::filterEdges(*graph, min_cost);

    PlantGraph dest = PlantGraph::empty();

    lemon::graphCopy(filtered, *dest.graph)
        .nodeMap(*point, *dest.point)
        .nodeMap(*radius, *dest.radius)
        .edgeMap(*length, *dest.length)
        .node(root, dest.root)
        .run();

    *this = std::move(dest);
    return *this;
}

} // namespace groot
