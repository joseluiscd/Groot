#include <TreePCL/mst.hpp>
#include <pcl/cloud_iterator.h>
#include <CGAL/squared_distance_3.h>
#include <lemon/list_graph.h>
#include <lemon/kruskal.h>
#include <algorithm>

//No tocar, peligro de muerte
Tree *MinimumSpanningTree::build(int root){
	CGALDelaunay delaunay;
	
	if(!initCompute()){
		return nullptr;
	}

    for(pcl::ConstCloudIterator<pcl::PointXYZ> it(*input_); it; it++){
        Point_3 p(it->x, it->y, it->z);
        CGALDelaunay::Vertex_handle h = delaunay.insert(p);
        h->info() = it.getCurrentPointIndex();
    }

    std::printf("Delaunay insertado\n");

    lemon::ListGraph graph;
    lemon::ListGraph::EdgeMap<double> distances(graph);
    lemon::ListGraph::NodeMap<int> points(graph);
    std::vector<lemon::ListGraph::Node> nodes(input_->size());
    std::vector<bool> inserted(input_->size());


    for(auto i=delaunay.finite_edges_begin(); i!=delaunay.finite_edges_end(); i++){
        CGALDelaunay::Vertex_handle v1 = i->first->vertex(i->second);
        CGALDelaunay::Vertex_handle v2 = i->first->vertex(i->third);

        double distance = CGAL::squared_distance(v1->point(), v2->point());

        int i1 = v1->info();
        int i2 = v2->info();

        lemon::ListGraph::Node n1, n2;

        if(inserted[i1]){
            n1 = nodes[i1];
        } else {
            n1 = graph.addNode();
            points[n1] = i1;
            nodes[i1] = n1;
            inserted[i1] = true;
        }

        if(inserted[i2]){
            n2 = nodes[i2];
        } else {
            n2 = graph.addNode();
            points[n2] = i2;
            nodes[i2] = n2;
            inserted[i2] = true;
        }
        
        lemon::ListGraph::Edge e = graph.addEdge(n1, n2);
        distances[e] = distance;
        
    }

    std::printf("Grafo delaunay creado\n");

    lemon::ListGraph::EdgeMap<bool> t(graph);
    lemon::kruskal(graph, distances, t);


    typedef lemon::FilterEdges<const lemon::ListGraph> Filtered;
    Filtered filtered = lemon::filterEdges(graph, t);
    std::printf("Edges: %d; Nodes: %d\n", lemon::countEdges(filtered), lemon::countNodes(filtered));

    // ORIENTATION
    Tree *r = new Tree(input_);
    
    std::stack<lemon::ListGraph::Node> next;
    lemon::ListGraph::NodeMap<bool> visited(graph, false);
    lemon::ListGraph::NodeMap<lemon::ListDigraph::Node> correspondence(graph);

    next.push(nodes[root]);
    correspondence[nodes[root]] = r->graph.addNode();

    while(!next.empty()){
        lemon::ListGraph::Node n = next.top();
        next.pop();
        
        visited[n] = true;

        //TODO: Comprobar esta lÃ­nea
        r->points[correspondence[n]] = points[n];

        for(Filtered::OutArcIt it(filtered, n); it != lemon::INVALID; ++it){
            lemon::ListGraph::Node m = filtered.target(it);

            if(!visited[m]){
                next.push(m);
                correspondence[m] = r->graph.addNode();

                r->graph.addArc(correspondence[n], correspondence[m]);
            }
        }
    }

    r->root = correspondence[nodes[root]];

    // DEVOLVER RESULTADOS
    std::printf("Edges: %d; Nodes: %d\n", lemon::countArcs(r->graph), lemon::countNodes(r->graph));

	deinitCompute();

    return r;
	
};